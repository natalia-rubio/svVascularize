<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Parameter Space · svVascularize Docs</title>

  <!-- Theme (match doc.html) -->
  <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />

  <!-- MathJax: render \( … \) and \[ … \]; ignore code/pre; provide argmin/argmax -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(','\\)']],
        displayMath: [['\\[','\\]']],
        packages: {'[+]': ['base','ams']},
        macros: { argmin: '\\operatorname*{arg\\,min}', argmax: '\\operatorname*{arg\\,max}' }
      },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
  <!-- Top nav -->
  <header class="topnav">
    <div class="container">
      <h1>svVascularize</h1>
      <nav>
        <a href="index.html#about">About</a>
        <a href="install.html">Installation</a>
        <a class="active" href="doc.html">Documentation</a>
        <a href="index.html#simulation">Simulation</a>
        <a href="https://pypi.org/project/svv/" target="_blank" rel="noopener">PyPI</a>
        <a href="https://github.com/SimVascular/svVascularize" target="_blank" rel="noopener">GitHub</a>
      </nav>
    </div>
  </header>

  <!-- Hero -->
  <section class="hero">
    <div class="container">
      <h2>Parameter Space &amp; Sampling</h2>
      <p>Generate diverse vascular trees by exploring objective weights, constraints, sampling, and stochastic seeds.</p>
      <a class="cta" href="doc.html">Back to Docs</a>
    </div>
  </section>

  <main class="container content">
    <h2 id="overview">Overview</h2>
    <p>
      <strong>svVascularize</strong> exposes a set of parameters that control how trees grow, how candidates are proposed,
      which constraints are enforced, and how the local optimization balances competing criteria.
      By sweeping these parameters and varying random seeds, you can produce families of trees tailored to
      specific tissues, printing constraints, or hemodynamic goals.
    </p>

    <div class="callout tip">
      Think of a run as \( \mathcal{T}(\theta, s) \): a tree produced from a parameter vector \( \theta \) and RNG seed \( s \).
      Exploring the space means scanning \( \theta \) (and replicates over \( s \)) to map design → outcome.
    </div>

    <h2 id="controls">Key controls</h2>
    <table>
      <thead>
        <tr><th>Category</th><th>Parameters (examples)</th><th>Effect</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Domain &amp; seeds</strong></td>
          <td>geometry (mesh/SDF), inlets/outlets, root pose, initial terminals</td>
          <td>Where growth is allowed; initial topology &amp; bias.</td>
        </tr>
        <tr>
          <td><strong>Demand &amp; targets</strong></td>
          <td>terminal count, volumetric demand field, sampling scheme (uniform / blue-noise / demand-weighted)</td>
          <td>Space-filling behavior; coverage uniformity; perfusion targeting.</td>
        </tr>
        <tr>
          <td><strong>Objective weights</strong></td>
          <td>\(J = \alpha\,\text{Power} + \beta\,\text{Volume} + \gamma\,\text{Smoothness} + \dots\)</td>
          <td>Trade-off energy vs. material vs. geometry.</td>
        </tr>
        <tr>
          <td><strong>Murray / flow model</strong></td>
          <td>exponent \( n \in [2.7,3.2] \), viscosity model, Poiseuille/0D options</td>
          <td>Radius scaling at bifurcations; shear/pressure profiles.</td>
        </tr>
        <tr>
          <td><strong>Hard constraints</strong></td>
          <td>clearance, non-intersection, domain inclusion, degree limits, min length</td>
          <td>Feasibility filter; shapes admissible solutions.</td>
        </tr>
        <tr>
          <td><strong>Soft constraints</strong></td>
          <td>angle bounds, taper/smoothness penalties, curvature limits</td>
          <td>Regularity of geometry; printability robustness.</td>
        </tr>
        <tr>
          <td><strong>Local optimization</strong></td>
          <td>neighborhood size, line-search/trust-region, tolerance, max iters</td>
          <td>Quality/speed of bifurcation placement &amp; sizing.</td>
        </tr>
        <tr>
          <td><strong>Stochasticity</strong></td>
          <td>RNG seed, candidate pool size, tempered acceptance, resample policy</td>
          <td>Diversity and exploration vs. exploitation.</td>
        </tr>
      </tbody>
    </table>

    <h2 id="objective">Objective &amp; constraints (at a glance)</h2>
    <p>
      We typically minimize a penalized composite objective:
    </p>
    <div class="mathblock">
      \[
        J(\mathcal{T}) = \alpha \sum_i R_i Q_i^2 \;+\; \beta\,\text{Volume}(\mathcal{T}) \;+\; \gamma\,\text{Smooth}(\mathcal{T})
        \;+\; \sum_k \lambda_k\,\phi_k(\mathcal{T}),
      \]
    </div>
    <p class="muted">
      Here \(R_i\) are segment resistances (Poiseuille), \(Q_i\) flows from a fast 0D solve per candidate, and \(\phi_k\) are soft-constraint penalties;
      Murray-like scaling \(r_0^{\,n}=r_1^{\,n}+r_2^{\,n}\) is enforced exactly or with a strong penalty during local refinement.
      Hard constraints (clearance, non-intersection, domain inclusion) act as feasibility filters before scoring.
    </p>

    <h2 id="sweeps">How to explore the space</h2>
    <ul>
      <li><strong>Grid / factorial sweep:</strong> Small dimensionality, coarse mapping of sensitivities.</li>
      <li><strong>Random / Sobol / Latin Hypercube:</strong> Space-filling samples for moderate/high dimensions.</li>
      <li><strong>Annealed sweeps:</strong> Start with relaxed constraints; tighten over stages to avoid stalls.</li>
      <li><strong>Replicates:</strong> For each \( \theta \), run \( s=1..R \) seeds to estimate variability and robustness.</li>
      <li><strong>Pareto fronts:</strong> When tuning \((\alpha,\beta,\gamma)\), track non-dominated solutions (e.g., power vs volume).</li>
    </ul>

    <h2 id="workflow">A practical sweep workflow</h2>
    <ol>
      <li><strong>Define</strong> your domain, inlet/outlet sites, and a base parameter template \( \theta_0 \).</li>
      <li><strong>Choose</strong> sweep axes (e.g., Murray exponent \(n\), terminal demand \(q_{\text{term}}\), angle penalty \(\gamma_{\angle}\)).</li>
      <li><strong>Sample</strong> \( \Theta = \{\theta^{(1)},\ldots,\theta^{(M)}\} \) (grid, Sobol, etc.) and replicates \( s=1..R \).</li>
      <li><strong>Generate</strong> trees \(\mathcal{T}(\theta^{(m)}, s)\); record metrics.</li>
      <li><strong>Select</strong> candidates by constraints + objective, or compute a Pareto set for multi-objective trade-offs.</li>
    </ol>

    <h3 id="code">Illustrative sweep (pseudo-API)</h3>
    <p class="muted">This mirrors typical svVascularize usage; adjust names to your actual API.</p>
    <pre data-copy><code class="language-python">import itertools, json, pathlib, numpy as np

# 1) Base parameters
base = dict(
    domain="heart_slice.sdf",                # or mesh
    inlets=[(12.0, 6.1, 4.7)],
    outlets=[],                              # optional; use forest-connection for loops
    terminals=1200,
    sampling="blue-noise",
    murray_n=3.0,
    weights=dict(alpha_power=1.0, beta_volume=0.1, gamma_smooth=0.05),
    constraints=dict(clearance=0.12, min_length=0.4, angle_min=25, angle_max=120),
    local_opt=dict(neighborhood=3.0, max_iters=20, tol=1e-3),
)

# 2) Define a sweep over two axes + RNG replicates
n_vals   = [2.8, 3.0, 3.2]
q_vals   = [0.8, 1.0, 1.2]                  # relative terminal demand scale (example)
seeds    = [11, 12, 13]

def paramsets():
    for n, q in itertools.product(n_vals, q_vals):
        p = json.loads(json.dumps(base))    # deep-ish copy
        p["murray_n"] = n
        p["demand_scale"] = q
        yield p

# 3) Run
outdir = pathlib.Path("runs/param_sweep")
outdir.mkdir(parents=True, exist_ok=True)

for i, theta in enumerate(paramsets()):
    for s in seeds:
        theta["seed"] = s
        # v = svv.Vascularizer(theta)               # construct
        # T = v.grow()                               # generate tree
        # metrics = v.metrics()                      # coverage, collisions, power, volume, etc.
        # v.save(outdir / f"tree_{i}_seed{s}.vtp")   # geometry
        # json.dump(metrics, open(outdir / f"tree_{i}_seed{s}.json","w"), indent=2)
        pass  # replace with real calls

# 4) Post-process: aggregate metrics and rank / build Pareto set
</code></pre>

    <h2 id="metrics">What to measure</h2>
    <table>
      <thead>
        <tr><th>Metric</th><th>Why it matters</th></tr>
      </thead>
      <tbody>
        <tr><td>Coverage (%) / voids</td><td>Uniform perfusion and space-filling behavior.</td></tr>
        <tr><td>Collisions / clearance violations</td><td>Feasibility and printability.</td></tr>
        <tr><td>Total power &amp; volume</td><td>Energy vs. material trade-off in \(J\).</td></tr>
        <tr><td>Radius &amp; length distributions</td><td>Physiological realism / manufacturability.</td></tr>
        <tr><td>Bifurcation angles / taper</td><td>Geometric regularity and flow quality.</td></tr>
        <tr><td>Shear &amp; pressure ranges</td><td>Hemodynamic safety windows.</td></tr>
        <tr><td>Connectivity / loops (forest)</td><td>Closed-circuit perfusion for tissues.</td></tr>
      </tbody>
    </table>

    <h2 id="defaults">Starting ranges (tunable)</h2>
    <ul>
      <li><strong>Murray exponent</strong> \(n \in [2.7, 3.2]\)</li>
      <li><strong>Angle bounds</strong> \([20^\circ, 120^\circ]\) with a soft penalty beyond</li>
      <li><strong>Clearance</strong> \(0.05\text{–}0.2\) × local radius scale (domain-dependent)</li>
      <li><strong>Min segment length</strong> \(0.3\text{–}1.0\) × voxel/feature size</li>
      <li><strong>Objective weights</strong> start \((\alpha,\beta,\gamma)=(1,0.1,0.05)\), then tune by Pareto analysis</li>
    </ul>

    <div class="callout warning">
      Over-tight constraints can stall growth. Use <em>progressive tightening</em> (anneal clearance/angles) or multi-resolution domains.
    </div>

    <h2 id="repro">Reproducibility checklist</h2>
    <ul>
      <li>Record: parameter vector \( \theta \), RNG seed \( s \), commit hash / version, domain asset checksums.</li>
      <li>Persist: metrics JSON + geometry artifacts (e.g., VTP/VTK) for each run.</li>
      <li>Log: accept/reject counts, constraint violations, local-opt iterations (helps diagnose stalls).</li>
    </ul>

    <h2 id="next">Next steps</h2>
    <ul>
      <li><a href="algorithm.html">Algorithm &amp; local optimization</a></li>
      <!--<li><a href="validation.html">Validation: geometric &amp; hemodynamic checks</a></li> -->
    </ul>
  </main>

  <footer>
    <div class="container">
      <p>&copy; 2025 SimVascular, Stanford University, The Regents of the University of California, and others —
        <a href="https://opensource.org/license/BSD-3-Clause" target="_blank" rel="noopener">BSD 3-Clause License</a>
      </p>
    </div>
  </footer>

  <script defer src="script.js"></script>
</body>
</html>
